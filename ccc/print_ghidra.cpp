#include "print_ghidra.h"

namespace ccc {

// print_ghidra_prologue
// print_ghidra_types
// print_ghidra_epilogue
static void create_top_level_types(FILE* dest, const std::vector<std::unique_ptr<ast::Node>>& ast_nodes, const std::map<std::string, s32>& type_lookup);
static void create_typedefs(FILE* dest, const std::vector<std::unique_ptr<ast::Node>>& ast_nodes, const std::map<std::string, s32>& type_lookup);
static void indent(FILE* dest, s32 level);

void print_ghidra_prologue(FILE* dest, const fs::path& input_file) {
	fprintf(dest, "// Generated by stdump from %s\n", input_file.filename().string().c_str());
	fprintf(dest, "//@author stdump\n");
	fprintf(dest, "//@category stdump\n");
	fprintf(dest, "\n");
	fprintf(dest, "import ghidra.app.script.GhidraScript;\n");
	fprintf(dest, "import ghidra.program.model.mem.*;\n");
	fprintf(dest, "import ghidra.program.model.lang.*;\n");
	fprintf(dest, "import ghidra.program.model.pcode.*;\n");
	fprintf(dest, "import ghidra.program.model.util.*;\n");
	fprintf(dest, "import ghidra.program.model.reloc.*;\n");
	fprintf(dest, "import ghidra.program.model.data.*;\n");
	fprintf(dest, "import ghidra.program.model.block.*;\n");
	fprintf(dest, "import ghidra.program.model.symbol.*;\n");
	fprintf(dest, "import ghidra.program.model.scalar.*;\n");
	fprintf(dest, "import ghidra.program.model.listing.*;\n");
	fprintf(dest, "import ghidra.program.model.address.*;\n");
	fprintf(dest, "\n");
	fprintf(dest, "public class GeneratedSymbolImporter extends GhidraScript {\n");
	fprintf(dest, "\tpublic void run() throws Exception {\n");
	fprintf(dest, "\t\tDataTypeManager data_type_manager = currentProgram.getDataTypeManager();\n");
	fprintf(dest, "\t\tint transaction_id = data_type_manager.startTransaction(\"stdump import script\");\n");
}

void print_ghidra_types(FILE* dest, const std::vector<std::unique_ptr<ast::Node>>& ast_nodes, const std::map<std::string, s32>& type_lookup) {
	create_top_level_types(dest, ast_nodes, type_lookup);
	create_typedefs(dest, ast_nodes, type_lookup);
}
void print_ghidra_epilogue(FILE* dest) {
	fprintf(dest, "\t\tdata_type_manager.endTransaction(transaction_id, true);\n");
	fprintf(dest, "\t}\n");
	fprintf(dest, "}\n");
}

static void create_top_level_types(FILE* dest, const std::vector<std::unique_ptr<ast::Node>>& ast_nodes, const std::map<std::string, s32>& type_lookup) {
	fprintf(dest, "\t\tprint(\"Creating top level types...\\n\");");
	for(s32 i = 0; i < (s32) ast_nodes.size(); i++) {
		ast::Node& node = *ast_nodes[i];
		switch(node.descriptor) {
			case ast::ARRAY: {
				break;
			}
			case ast::BITFIELD: {
				break;
			}
			case ast::FUNCTION: {
				break;
			}
			case ast::INLINE_ENUM: {
				break;
			}
			case ast::INLINE_STRUCT_OR_UNION: {
				const auto& struct_or_union = node.as<ast::InlineStructOrUnion>();
				if(struct_or_union.is_struct) {
					fprintf(dest, "\t\tStructureDataType type_%d = new StructureDataType(null, \"%s\", 0x%x);\n",
						i, struct_or_union.name.c_str(), struct_or_union.size_bits / 8);
				} else {
					fprintf(dest, "\t\tUnionDataType type_%d = new UnionDataType(null, \"%s\");\n",
						i, struct_or_union.name.c_str());
				}
				fprintf(dest, "\t\tdata_type_manager.addDataType(type_%d, null);\n", i);
				break;
			}
			case ast::POINTER: {
				break;
			}
			case ast::REFERENCE: {
				break;
			}
			case ast::TYPE_NAME: {
				break;
			}
		}
	}
}

static void create_typedefs(FILE* dest, const std::vector<std::unique_ptr<ast::Node>>& ast_nodes, const std::map<std::string, s32>& type_lookup) {
	fprintf(dest, "\t\tprint(\"Creating typedefs...\\n\");");
	for(s32 i = 0; i < (s32) ast_nodes.size(); i++) {
		ast::Node& node = *ast_nodes[i];
		switch(node.descriptor) {
			case ast::ARRAY:
			case ast::BITFIELD:
			case ast::FUNCTION:
			case ast::INLINE_ENUM:
			case ast::INLINE_STRUCT_OR_UNION:
			case ast::POINTER:
			case ast::REFERENCE: {
				break;
			}
			case ast::TYPE_NAME: {
				if(node.storage_class == ast::StorageClass::TYPEDEF) {
					const ast::TypeName& type_name = node.as<ast::TypeName>();
					auto type_index = type_lookup.find(type_name.type_name);
					if(type_index != type_lookup.end() && ast_nodes[type_index->second]->descriptor == ast::INLINE_STRUCT_OR_UNION) {
						fprintf(dest, "\t\tTypedefDataType type_%d = new TypedefDataType(\"%s\", type_%d);",
							i, type_name.name.c_str(), type_index->second);
					}
				}
				break;
			}
		}
	}
}

static void indent(FILE* dest, s32 level) {
	for(s32 i = 0; i < level; i++) {
		fputc('\t', dest);
	}
}

}
